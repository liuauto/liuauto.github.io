<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>l1_logreg: File format</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="fileformat">File format </a></h1><h2><a class="anchor" name="infile">
Input file format</a></h2>
<code>l1_logreg</code> requires two data files:<ul>
<li><code>feature_file</code></li><li><code>class_file</code></li></ul>
<p>
<code>feature_file</code> contains the feature matrix for training examples and <code>class_file</code> contains the corresponding class vector of training examples.<p>
Data in <code>feature_file</code> and <code>class_file</code> are stored in Matrix Market (MM) exchange format; see <a href="http://math.nist.gov/MatrixMarket/formats.html">http://math.nist.gov/MatrixMarket/formats.html</a> for more information.<p>
<ul>
<li>Dense matrix is stored in array format: <pre>
%%MatrixMarket matrix array real general
m &nbsp; n
x<sub>11</sub>
x<sub>21</sub>
...
x<sub>m1</sub>
x<sub>12</sub>
x<sub>22</sub>
...
x<sub>m2</sub>
...
x<sub>1n</sub>
...
x<sub>mn</sub>
</pre></li></ul>
<p>
The first line contains the header of Matrix Market format. Here, it indicates that the object being represented is a matrix in array format and that the numeric data is real and represented in general form.<p>
The second line contains the number of rows <code>m</code>, and the number of columns <code>n</code> of the feature matrix. From the third row, the matrix is stored in column-oriented order.<ul>
<li>Sparse matrix is stored as follows: <pre>
%%MatrixMarket matrix coordinate real general
m &nbsp;  n &nbsp;  nnz
i<sub>1</sub> &nbsp; j<sub>1</sub> &nbsp; x<sub>i1 j1</sub>
i<sub>1</sub> &nbsp; j<sub>2</sub> &nbsp; x<sub>i1 j2</sub>
&nbsp; &nbsp; ...
i<sub>2</sub> &nbsp; j<sub>1</sub> &nbsp; x<sub>i2 j1</sub>
i<sub>2</sub> &nbsp; j<sub>2</sub> &nbsp; x<sub>i2 j2</sub>
&nbsp; &nbsp; ...
i<sub>p</sub> &nbsp; j<sub>q</sub> &nbsp; x<sub>ip jq</sub>
</pre></li></ul>
<p>
The first line contains the header of Matrix Market format. Here, it indicates that the object being represented is a matrix in coordinate format and that the numeric data is real and represented in general form. The second row contains the number of rows <code>m</code>, the number of columns <code>n</code> and the number of non-zero entries <code>p</code> of the feature matrix. From the third row, the matrix is stored in coordinate format: the first column is the example (row) index, the second column is the feature (column) index, the third column is the corresponding value, of the feature matrix.<p>
Note that the class vector is stored as a matrix in Matrix Market format, whose size is (m x 1). Each class can have a value in [+1,-1]. Here, +1 for positive class, and -1 for negative class.<h2><a class="anchor" name="outfile">
Output file format</a></h2>
<ul>
<li><code>model_file</code> <br>
 <code>model_file</code> is generated when <code>l1_logreg_train</code> is executed. It contains a shifted intercept <code>q</code> and normalized coefficients <code>r<sub>i</sub>, i=1,...,n</code>. The following vector will be stored in Matrix Market format: <pre>
%%MatrixMarket matrix array real general
m &nbsp; 1
q
r<sub>1</sub>
r<sub>2</sub>
...
r<sub>m-1</sub>
</pre> Here, <code>n = m-1</code>.</li></ul>
<p>
Without standardization, we can perform classification on a test set <code>X<sub>test</sub></code> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ t =\mbox{sgn}\left(X_{test}w+\mathbf{1}v\right) \]" src="form_26.png">
<p>
 where <code>t</code> is the prediction (or classification result) for the test data set. Thus, <code>q</code> is set to the intercept <code>v</code> and the normalized coefficients are set to the coefficients values, that is, <code>r<sub>i</sub></code>=<img class="formulaInl" alt="$ w_i $" src="form_27.png">, i=1,...,n.<p>
When standardization is used, the user need to perform the following: <ol>
<li>
standardize test example set </li>
<li>
apply a linear classifier of intercept and coefficients </li>
</ol>
This process can be summarized as follows: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ t =\mbox{sgn}\left((X_{test}-\mathbf{1}\mu^T)\mbox{diag}(\sigma)^{-1}w+\mathbf{1}v\right) \]" src="form_28.png">
<p>
 where <code>t</code> is the prediction (or classification result) for the test data set.<p>
For step 1, we need to store the column mean <img class="formulaInl" alt="$\mu$" src="form_29.png"> and column standard deviation <img class="formulaInl" alt="$\sigma$" src="form_30.png"> of training example set, and everytime we do classification, we should standardize the test data set. However, this additional effort can be easily avoided by exploiting the property of standardization. We set the normalized coefficients <code>r<sub>i</sub></code> to the coefficients divided by corresponding standard-deviations, that is, <p class="formulaDsp">
<img class="formulaDsp" alt="\[ r=\mbox{diag}(\sigma)^{-1}w. \]" src="form_31.png">
<p>
 Also, the shifted intercept is set to <p class="formulaDsp">
<img class="formulaDsp" alt="\[ q=v-\mu^T\mbox{diag}(\sigma)^{-1}w. \]" src="form_32.png">
<p>
 Then, the classification can be done as follows: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ t =\mbox{sgn}\left(X_{test}r+\mathbf{1}q\right), \]" src="form_33.png">
<p>
 where <code>t</code> is the prediction (or classification result) for the test data set.<p>
<ul>
<li><code>result_file</code> <br>
 <code>result_file</code> is generated when <code>l1_logreg_classify</code> is executed. The value of <code>t<sub>i</sub></code> <img class="formulaInl" alt="$ \in $" src="form_34.png"> [+1,-1] of <code>i</code>th line corresponds to the classification result of ith example. Here, +1 for positive class, and -1 for negative class. <pre>
    t<sub>1</sub>
    t<sub>2</sub>
    ...
    t<sub>m</sub>
</pre></li></ul>
<h2><a class="anchor" name="smallex">
Small example</a></h2>
Consider a small problem with 3 examples and 4 features. <code> <pre>
           feature 1   feature 2   feature 3   feature 4       class
example 1      3           0           1          -2             1
example 2      0           0           2           5            -1
example 3      7           1          -4           0             1
</pre> </code> Feature file of this problem for dense format is: <pre>
%%MatrixMarket matrix array real general
3 4
 3
 0
 7
 0
 0
 1
 1
 2
-4
-2
 5
 0
</pre> Feature file for sparse format is: <pre>
%%MatrixMarket matrix coordinate real general
3 4 8
1 1  3
3 1  7
3 2  1
1 3  1
2 3  2
3 3 -4
1 4 -2
2 4  5
</pre> Class file for both dense and sparse format is: <pre>
%%MatrixMarket matrix array real general
3 1
 1
-1
 1
</pre><h2><a class="anchor" name="datagen">
Writing matrices in Matrix Market format</a></h2>
You may directly write matrices in Matrix Market format using any editor or C programs. Also, various software packages are available for reading and writing matrices in Matrix Market format; see <a href="http://math.nist.gov/MatrixMarket/formats.html#MMformat.">http://math.nist.gov/MatrixMarket/formats.html#MMformat.</a><h3><a class="anchor" name="matlabmm">
Writing matrices in Matrix Market format using Matlab</a></h3>
Feature matrices and outcome (class) vectors can be easily written in Matrix Market format within Matlab.<p>
For example, the problem data of the above example can be stored to files by typing the following script in Matlab: <pre>
    &gt;&gt; X = [3 0 1 -2; 0 0 2 5; 7 1 -4 0];
    &gt;&gt; b = [1; -1; 1];
    &gt;&gt; mmwrite('exd_simple_X',X);
    &gt;&gt; mmwrite('exd_simple_b',b);
</pre> This sequence of commands will generate a dense feature matrix <code>exd_simple_X</code> and the corresponding class vector <code>exd_simple_b</code>.<p>
Sparse matrix can be written to a file in a similar way: <pre>
    &gt;&gt; X = [3 0 1 -2; 0 0 2 5; 7 1 -4 0];
    &gt;&gt; b = [1; -1; 1];
    &gt;&gt; X = sparse(X);
    &gt;&gt; mmwrite('exs_simple_X',X);
    &gt;&gt; mmwrite('exs_simple_b',b);
</pre> This sequence of commands will generate a sparse feature matrix <code>exs_simple_X</code> and the corresponding class vector <code>exs_simple_b</code>. </div>
<hr size="1"><address style="align: right;"><small>
Generated on Mon May 25 19:15:19 2009 for l1_logreg by Doxygen 1.5.5</small></address>
</body>
</html>
